TITLE: Full Raycast Command with Pagination (TSX)
DESCRIPTION: A complete example of a Raycast command component using `useCachedPromise` with simulated page-based pagination. It integrates the hook with React state for search text and renders the results using Raycast's `List` component.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/utils-reference/react-hooks/useCachedPromise.md#_snippet_7

LANGUAGE: TSX
CODE:
```
import { setTimeout } from "node:timers/promises";
import { useState } from "react";
import { List } from "@raycast/api";
import { useCachedPromise } from "@raycast/utils";

export default function Command() {
  const [searchText, setSearchText] = useState("");

  const { isLoading, data, pagination } = useCachedPromise(
    (searchText: string) => async (options: { page: number }) => {
      await setTimeout(200);
      const newData = Array.from({ length: 25 }, (_v, index) => ({
        index,
        page: options.page,
        text: searchText,
      }));
      return { data: newData, hasMore: options.page < 10 };
    },
    [searchText],
  );

  return (
    <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>
      {data?.map((item) => (
        <List.Item
          key={`${item.page} ${item.index} ${item.text}`}
          title={`Page ${item.page} Item ${item.index}`}
          subtitle={item.text}
        />
      ))}
    </List>
  );
}
```

----------------------------------------

TITLE: Demonstrating Array Ownership Transfer in Cairo
DESCRIPTION: Shows an example where an array `arr` is passed to two functions, `foo` and `bar`. Due to Cairo's ownership rules, the array's ownership is moved to `foo` on the first call, making it invalid for the subsequent call to `bar`. This prevents double writing to the same memory.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/charged/assets/cairoBook/ch03-01-what-is-ownership.md#_snippet_3

LANGUAGE: Cairo
CODE:
```
use array::ArrayTrait;
fn foo(arr: Array<u128>) {
}

fn bar(arr:Array<u128>){
}

fn main() {
    let mut arr = ArrayTrait::<u128>::new();
    foo(arr);
    bar(arr);
}
```

----------------------------------------

TITLE: Error When Changing Type with mut in Cairo
DESCRIPTION: This Cairo snippet demonstrates the limitation of using `mut` instead of `let` for type conversion. It shows that attempting to reassign a variable declared with `mut` to a value of a different type results in a compile-time error, unlike shadowing with `let`.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/charged/assets/cairoBook/ch02-01-variables-and-mutability.md#_snippet_7

LANGUAGE: cairo
CODE:
```
use debug::PrintTrait;
use traits::Into;
fn main() {
    let mut x = 2_u64;
    x.print();
    x = x.into();
    x.print()
}
```

----------------------------------------

TITLE: Ensure Stepper Step Accessibility (Mantine Stepper, TSX)
DESCRIPTION: Provide examples showing how to make Stepper.Step components accessible to screen readers by providing label, description, aria-label, or title props, especially when not displaying visible text.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/core/Stepper.mdx#_snippet_3

LANGUAGE: tsx
CODE:
```
<Stepper.Step /> // -> not ok, empty labels for screen reader
<Stepper.Step label="Step 1" description="Create an account" /> // -> ok
<Stepper.Step aria-label="Create an account" /> // -> ok
<Stepper.Step title="Create an account" /> // -> ok
```

----------------------------------------

TITLE: Implementing Form Validation with useForm Hook (TypeScript)
DESCRIPTION: This snippet demonstrates how to use the `useForm` hook from `@raycast/utils` to handle form state, submission, and validation in a Raycast extension. It shows how to define validation rules for specific fields (`name` and `password`) and how the `onSubmit` callback is triggered only when validation passes. Requires the `@raycast/utils` package.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/information/best-practices.md#_snippet_2

LANGUAGE: tsx
CODE:
```
import { Action, ActionPanel, Form, showToast, Toast } from "@raycast/api";
import { useForm, FormValidation } from "@raycast/utils";

interface SignUpFormValues {
  name: string;
  password: string;
}

export default function Command() {
  const { handleSubmit, itemProps } = useForm<SignUpFormValues>({
    onSubmit(values) {
      showToast({
        style: Toast.Style.Success,
        title: "Yay!",
        message: `${values.name} account created`,
      });
    },
    validation: {
      name: FormValidation.Required,
      password: (value) => {
        if (value && value.length < 8) {
          return "Password must be at least 8 symbols";
        } else if (!value) {
          return "The item is required";
        }
      },
    },
  });
  return (
    <Form
      actions={
        <ActionPanel>
          <Action.SubmitForm title="Submit" onSubmit={handleSubmit} />
        </ActionPanel>
      }
    >
      <Form.TextField title="Full Name" placeholder="Tim Cook" {...itemProps.name} />
      <Form.PasswordField title="New Password" {...itemProps.password} />
    </Form>
  );
}
```

----------------------------------------

TITLE: Implement Toggle Todo Action in Raycast List Item (TypeScript)
DESCRIPTION: Adds functionality to mark todos as complete or incomplete. It includes a `handleToggle` function to update the state based on the item's index and defines a `<ToggleTodoAction>` component. This action is added to the `<ActionPanel>` of each `<List.Item>`, and the item's icon is updated based on the `isCompleted` state.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/examples/todo-list.md#_snippet_3

LANGUAGE: typescript
CODE:
```
export default function Command() {
  const [todos, setTodos] = useState<Todo[]>([]);

  // ...

  function handleToggle(index: number) {
    const newTodos = [...todos];
    newTodos[index].isCompleted = !newTodos[index].isCompleted;
    setTodos(newTodos);
  }

  return (
    <List
      actions={
        <ActionPanel>
          <CreateTodoAction onCreate={handleCreate} />
        </ActionPanel>
      }
    >
      {todos.map((todo, index) => (
        <List.Item
          key={index}
          icon={todo.isCompleted ? Icon.Checkmark : Icon.Circle}
          title={todo.title}
          actions={
            <ActionPanel>
              <ActionPanel.Section>
                <ToggleTodoAction todo={todo} onToggle={() => handleToggle(index)} />
              </ActionPanel.Section>
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}

function ToggleTodoAction(props: { todo: Todo; onToggle: () => void }) {
  return (
    <Action
      icon={props.todo.isCompleted ? Icon.Circle : Icon.Checkmark}
      title={props.todo.isCompleted ? "Uncomplete Todo" : "Complete Todo"}
      onAction={props.onToggle}
    />
  );
}
```

----------------------------------------

TITLE: Parsing felt252 to u8 using try_into in Cairo
DESCRIPTION: This snippet shows the beginning of a `parse_u8` function in Cairo. It takes a `felt252` and attempts to convert it to a `u8` using the `try_into` method. It returns a `Result<u8, felt252>`, indicating success with the converted value or failure with an error value.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/charged/assets/cairoBook/ch09-02-error-handling.md#_snippet_5

LANGUAGE: Cairo
CODE:
```
fn parse_u8(s: felt252) -> Result<u8, felt252> {
    match s.try_into() {
        Option::Some(value) => Result::Ok(value),
```

----------------------------------------

TITLE: Using Other Overlays Inside Mantine Popover (TSX)
DESCRIPTION: Provides an example of using other overlay components (like Menu, Autocomplete, DatePicker) inside a Popover by disabling their `withinPortal` prop. This is necessary because Popover listens for outside clicks and components rendering into a Portal would not be considered 'inside' the Popover.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/core/Popover.mdx#_snippet_4

LANGUAGE: tsx
CODE:
```
<Popover>
  <Menu withinPortal={false} />
  <Autocomplete withinPortal={false} />
  <DatePicker withinPortal={false} />
</Popover>
```

----------------------------------------

TITLE: Replace DisplayText Extra large with Text heading3xl - JSX
DESCRIPTION: Migrate from the deprecated DisplayText component with size="extraLarge" to the new Text component, using the heading3xl variant and setting the semantic element to a paragraph (<p>).
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/shopify-polaris-docs/assets/docs/typography/text.mdx#_snippet_2

LANGUAGE: diff
CODE:
```
- <DisplayText size="extraLarge">Sales this year</DisplayText>
+ <Text variant="heading3xl" as="p">Sales this year</Text>
```

----------------------------------------

TITLE: TSX Example Using useFetch in Raycast Command
DESCRIPTION: This example demonstrates how to use the `useFetch` hook within a Raycast functional command component written in TSX. It shows importing necessary components and the hook, calling `useFetch` with a URL, accessing the `isLoading` and `data` properties from the returned state to update the UI, and using the `revalidate` method to implement a 'Reload' action via an `ActionPanel` and `Action` component.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/utils-reference/react-hooks/useFetch.md#_snippet_1

LANGUAGE: TSX
CODE:
```
import { Detail, ActionPanel, Action } from "@raycast/api";
import { useFetch } from "@raycast/utils";

export default function Command() {
  const { isLoading, data, revalidate } = useFetch("https://api.example");

  return (
    <Detail
      isLoading={isLoading}
      markdown={data}
      actions={
        <ActionPanel>
          <Action title="Reload" onAction={() => revalidate()} />
        </ActionPanel>
      }
    />
  );
}
```

----------------------------------------

TITLE: Displaying List Item Details and Actions (TypeScript/JSX)
DESCRIPTION: Provides a comprehensive example demonstrating state management (`useState`), data fetching (`useCachedPromise`), conditional rendering of item details (`List.Item.Detail`) or accessories, and multiple actions (`ActionPanel`, `Action.OpenInBrowser`, `Action`).
SOURCE: https://github.com/raycast/extensions/blob/main/docs/api-reference/user-interface/list.md#_snippet_8

LANGUAGE: TypeScript
CODE:
```
import { useState } from "react";
import { Action, ActionPanel, List } from "@raycast/api";
import { useCachedPromise } from "@raycast/utils";

interface Pokemon {
  name: string;
  height: number;
  weight: number;
  id: string;
  types: string[];
  abilities: Array<{ name: string; isMainSeries: boolean }>;
}

const pokemons: Pokemon[] = [
  {
    name: "bulbasaur",
    height: 7,
    weight: 69,
    id: "001",
    types: ["Grass", "Poison"],
    abilities: [
      { name: "Chlorophyll", isMainSeries: true },
      { name: "Overgrow", isMainSeries: true },
    ],
  },
  {
    name: "ivysaur",
    height: 10,
    weight: 130,
    id: "002",
    types: ["Grass", "Poison"],
    abilities: [
      { name: "Chlorophyll", isMainSeries: true },
      { name: "Overgrow", isMainSeries: true },
    ],
  },
];

export default function Command() {
  const [showingDetail, setShowingDetail] = useState(true);
  const { data, isLoading } = useCachedPromise(() => new Promise<Pokemon[]>((resolve) => resolve(pokemons)));

  return (
    <List isLoading={isLoading} isShowingDetail={showingDetail}>
      {data &&
        data.map((pokemon) => {
          const props: Partial<List.Item.Props> = showingDetail
            ? {
                detail: (
                  <List.Item.Detail
                    markdown={`![Illustration](https://assets.pokemon.com/assets/cms2/img/pokedex/full/${
                      pokemon.id
                    }.png)\n\n${pokemon.types.join(" ")}`}
                  />
                ),
              }
            : { accessories: [{ text: pokemon.types.join(" ") }] };
          return (
            <List.Item
              key={pokemon.id}
              title={pokemon.name}
              subtitle={`#${pokemon.id}`}
              {...props}
              actions={
                <ActionPanel>
                  <Action.OpenInBrowser url={`https://www.pokemon.com/us/pokedex/${pokemon.name}`} />
                  <Action title="Toggle Detail" onAction={() => setShowingDetail(!showingDetail)} />
                </ActionPanel>
              }
            />
          );
        })}
    </List>
  );
}
```

----------------------------------------

TITLE: Implementing Dark/Light Theme with Mantine ColorSchemeProvider (TSX)
DESCRIPTION: Provides a comprehensive example of setting up and using the `ColorSchemeProvider` component to manage the application's color scheme (light/dark). It shows how to define the color scheme state, toggle it, and consume the color scheme and toggle function in other components using the `useMantineColorScheme` hook.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/changelog/3-0-0.mdx#_snippet_2

LANGUAGE: tsx
CODE:
```
import { MantineProvider, ColorSchemeProvider, ColorScheme } from "@mantine/core";

export default function Demo() {
  const [colorScheme, setColorScheme] = useState("light");
  const toggleColorScheme = (value?: ColorScheme) =>
    setColorScheme(value || (colorScheme === "dark" ? "light" : "dark"));

  return (
    <ColorSchemeProvider colorScheme={colorScheme} toggleColorScheme={toggleColorScheme}>
      <MantineProvider theme={{ colorScheme }}>
        <App />
      </MantineProvider>
    </ColorSchemeProvider>
  );
}

// ...later in other component
import { ActionIcon, useMantineColorScheme } from "@mantine/core";
import { SunIcon, MoonIcon } from "@modulz/radix-icons";

function Demo() {
  const { colorScheme, toggleColorScheme } = useMantineColorScheme();
  const dark = colorScheme === "dark";

  return (
    <ActionIcon
      variant="outline"
      color={dark ? "yellow" : "blue"}
      onClick={() => toggleColorScheme()}
      title="Toggle color scheme"
    >
      {dark ? <SunIcon style={{ width: 18, height: 18 }} /> : <MoonIcon style={{ width: 18, height: 18 }} />}
    </ActionIcon>
  );
}
```

----------------------------------------

TITLE: Complete Raycast Todo List Command with Create, Toggle, and Delete Actions (TypeScript)
DESCRIPTION: Presents the full code for the Raycast command, including state initialization, handler functions for creating, toggling, and deleting todos, the main `Command` component rendering the list with actions, and definitions for all helper components (`CreateTodoForm`, `CreateTodoAction`, `ToggleTodoAction`, `DeleteTodoAction`). This snippet shows the complete integration of all features.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/examples/todo-list.md#_snippet_5

LANGUAGE: typescript
CODE:
```
import { Action, ActionPanel, Form, Icon, List, useNavigation } from "@raycast/api";
import { useState } from "react";

interface Todo {
  title: string;
  isCompleted: boolean;
}

export default function Command() {
  const [todos, setTodos] = useState<Todo[]>([
    { title: "Write a todo list extension", isCompleted: false },
    { title: "Explain it to others", isCompleted: false },
  ]);

  function handleCreate(todo: Todo) {
    const newTodos = [...todos, todo];
    setTodos(newTodos);
  }

  function handleToggle(index: number) {
    const newTodos = [...todos];
    newTodos[index].isCompleted = !newTodos[index].isCompleted;
    setTodos(newTodos);
  }

  function handleDelete(index: number) {
    const newTodos = [...todos];
    newTodos.splice(index, 1);
    setTodos(newTodos);
  }

  return (
    <List
      actions={
        <ActionPanel>
          <CreateTodoAction onCreate={handleCreate} />
        </ActionPanel>
      }
    >
      {todos.map((todo, index) => (
        <List.Item
          key={index}
          icon={todo.isCompleted ? Icon.Checkmark : Icon.Circle}
          title={todo.title}
          actions={
            <ActionPanel>
              <ActionPanel.Section>
                <ToggleTodoAction todo={todo} onToggle={() => handleToggle(index)} />
              </ActionPanel.Section>
              <ActionPanel.Section>
                <CreateTodoAction onCreate={handleCreate} />
                <DeleteTodoAction onDelete={() => handleDelete(index)} />
              </ActionPanel.Section>
            </ActionPanel>
          }
        />
      ))}
    </List>
  );
}

function CreateTodoForm(props: { onCreate: (todo: Todo) => void }) {
  const { pop } = useNavigation();

  function handleSubmit(values: { title: string }) {
    props.onCreate({ title: values.title, isCompleted: false });
    pop();
  }

  return (
    <Form
      actions={
        <ActionPanel>
          <Action.SubmitForm title="Create Todo" onSubmit={handleSubmit} />
        </ActionPanel>
      }
    >
      <Form.TextField id="title" title="Title" />
    </Form>
  );
}

function CreateTodoAction(props: { onCreate: (todo: Todo) => void }) {
  return (
    <Action.Push
      icon={Icon.Pencil}
      title="Create Todo"
      shortcut={{ modifiers: ["cmd"], key: "n" }}
      target={<CreateTodoForm onCreate={props.onCreate} />}?
    />
  );
}

function ToggleTodoAction(props: { todo: Todo; onToggle: () => void }) {
  return (
    <Action
      icon={props.todo.isCompleted ? Icon.Circle : Icon.Checkmark}
      title={props.todo.isCompleted ? "Uncomplete Todo" : "Complete Todo"}
      onAction={props.onToggle}
    />
  );
}

function DeleteTodoAction(props: { onDelete: () => void }) {
  return (
    <Action
      icon={Icon.Trash}
      title="Delete Todo"
      shortcut={{ modifiers: ["ctrl"], key: "x" }}
      onAction={props.onDelete}
    />
  );
}
```

----------------------------------------

TITLE: Implementing Custom Filtering with Raycast Grid (TypeScript)
DESCRIPTION: Demonstrates how to disable Raycast's built-in filtering and implement custom filtering logic based on search text changes using React hooks (`useState`, `useEffect`) and array methods (`filter`, `some`, `includes`). Requires `@raycast/api` and React.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/api-reference/user-interface/grid.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { useEffect, useState } from "react";
import { Grid } from "@raycast/api";

const items = [
  { content: "ðŸ™ˆ", keywords: ["see-no-evil", "monkey"] },
  { content: "ðŸ¥³", keywords: ["partying", "face"] },
];

export default function Command() {
  const [searchText, setSearchText] = useState("");
  const [filteredList, filterList] = useState(items);

  useEffect(() => {
    filterList(items.filter((item) => item.keywords.some((keyword) => keyword.includes(searchText))));
  }, [searchText]);

  return (
    <Grid
      columns={5}
      inset={Grid.Inset.Large}
      filtering={false}
      onSearchTextChange={setSearchText}
      navigationTitle="Search Emoji"
      searchBarPlaceholder="Search your favorite emoji"
    >
      {filteredList.map((item) => (
        <Grid.Item key={item.content} content={item.content} />
      ))}
    </Grid>
  );
}
```

----------------------------------------

TITLE: Comparing useEffect and useShallowEffect with Object Dependency (TSX)
DESCRIPTION: Demonstrates the difference in behavior between React's `useEffect` and `@mantine/hooks`' `useShallowEffect` when using an object literal as a dependency. `useEffect` triggers on every render, while `useShallowEffect` triggers only once due to shallow comparison.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/hooks/use-shallow-effect.mdx#_snippet_0

LANGUAGE: tsx
CODE:
```
import { useEffect } from "react";
import { useShallowEffect } from "@mantine/hooks";

// Will be called on each render
useEffect(() => {}, [{ a: 1 }]);

// Will be called only once
useShallowEffect(() => {}, [{ a: 1 }]);
```

----------------------------------------

TITLE: Basic Raycast usePromise Usage (Non-Paginated) (TS)
DESCRIPTION: Illustrates the standard usage of the `usePromise` hook for fetching data asynchronously without pagination. The function passed to `usePromise` directly performs the asynchronous operation and returns the result. This is shown as a contrast to the pagination approach.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/utils-reference/react-hooks/usePromise.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
const { isLoading, data } = usePromise(
  async (searchText: string) => {
    const data = await getUser(); // or any asynchronous logic you need to perform
    return data;
  },
  [searchText],
);
```

----------------------------------------

TITLE: Copy Content to Clipboard Raycast TypeScript
DESCRIPTION: This snippet demonstrates how to use `Clipboard.copy` to place various types of content onto the system clipboard within a Raycast extension. It shows examples for copying plain text, text wrapped in a `Content` object, a file path using a `Content` object, and text marked as confidential using the `concealed` option. It requires the `@raycast/api` dependency.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/api-reference/clipboard.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { Clipboard } from "@raycast/api";

export default async function Command() {
  // copy some text
  await Clipboard.copy("https://raycast.com");

  const textContent: Clipboard.Content = {
    text: "https://raycast.com",
  };
  await Clipboard.copy(textContent);

  // copy a file
  const file = "/path/to/file.pdf";
  try {
    const fileContent: Clipboard.Content = { file };
    await Clipboard.copy(fileContent);
  } catch (error) {
    console.log(`Could not copy file '${file}'. Reason: ${error}`);
  }

  // copy confidential data
  await Clipboard.copy("my-secret-password", { concealed: true });
}
```

----------------------------------------

TITLE: Using Mantine useForm with Optional Error Messages - TSX
DESCRIPTION: Demonstrates how to initialize the Mantine `useForm` hook with `initialValues`, `validationRules`, and the new optional `errorMessages`. Shows how to trigger validation and access the `errors` object, including how error messages are applied and cleared.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/changelog/3-3-0.mdx#_snippet_0

LANGUAGE: tsx
CODE:
```
const form = useForm({
  initialValues: { name: "", age: 0 },
  validationRules: {
    name: (value) => value.trim().length >= 2,
    age: (value) => value > 21,
  },
  errorMessages: {
    name: "Name must include at least 2 characters",
    age: "You must be 21 or older to enter",
  },
});

form.validate();
form.errors;
// -> { name: 'Name must include at least 2 characters', age: 'You must be 21 or older to enter' }

form.setFieldValue("name", "John");
form.validate();
form.errors;
// -> { name: null, age: 'You must be 21 or older to enter' }
```

----------------------------------------

TITLE: Illustrating useUncontrolled Initial Value Logic (TSX)
DESCRIPTION: Provides examples demonstrating how the `useUncontrolled` hook determines the initial state value based on the `value`, `defaultValue`, and `finalValue` props, especially when the provided `rule` function is applied. Shows scenarios for controlled components and cases where `value` or `defaultValue` fail the rule.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/hooks/use-uncontrolled.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
// defaultValue and finalValue are ignored for controlled components
// _value === 'Hello'
<CustomInput value="Hello" defaultValue="There" onChange={() => {}} />

// Since value prop does not meet requirements default value will be used instead
// _value === 'There'
<CustomInput value={null} defaultValue="There" />

// When both value and defaultValue fail to meet requirements, finalValue will be used
// _value === 'Final'
<CustomInput value={null} defaultValue={null} />
```

----------------------------------------

TITLE: Handling Various Data Types with useShallowEffect Dependencies (TSX)
DESCRIPTION: Illustrates how `useShallowEffect` performs shallow comparison for dependencies across different data types, including primitive values, arrays of primitives, objects of primitives, and arrays containing objects, showing when the effect callback will or will not be triggered.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/hooks/use-shallow-effect.mdx#_snippet_1

LANGUAGE: tsx
CODE:
```
// Primitive values are handled like in useEffect
useShallowEffect(() => {}, [1, 2, 3]);

// Arrays with primitive values will not trigger callback
useShallowEffect(() => {}, [[1], [2], [3]]);

// Objects with primitive values will not trigger callback
useShallowEffect(() => {}, [{ a: 1 }, { b: 2 }]);

// Arrays with objects will trigger callback since values are not shallow equal
useShallowEffect(() => {}, [[{ a: 1 }], [{ b: 2 }]]);
```

----------------------------------------

TITLE: Implementing Raycast Share Secret Action (TypeScript)
DESCRIPTION: This snippet defines the `<ShareSecretAction>` component used within the form's action panel. It renders an `<Action.SubmitForm>` button. The `onSubmit` handler (`handleSubmit`) validates the input, shows toast notifications for progress and errors, makes an HTTP POST request using `got` to a Doppler API endpoint with the form data, copies the resulting URL to the clipboard, and updates the toast notification upon success or failure.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/examples/doppler.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
function ShareSecretAction() {
  async function handleSubmit(values: { secret: string; expireViews: number; expireDays: number }) {
    if (!values.secret) {
      showToast({
        style: Toast.Style.Failure,
        title: "Secret is required",
      });
      return;
    }

    const toast = await showToast({
      style: Toast.Style.Animated,
      title: "Sharing secret",
    });

    try {
      const { body } = await got.post("https://api.doppler.com/v1/share/secrets/plain", {
        json: {
          secret: values.secret,
          expire_views: values.expireViews,
          expire_days: values.expireDays,
        },
        responseType: "json",
      });

      await Clipboard.copy((body as any).authenticated_url);

      toast.style = Toast.Style.Success;
      toast.title = "Shared secret";
      toast.message = "Copied link to clipboard";
    } catch (error) {
      toast.style = Toast.Style.Failure;
      toast.title = "Failed sharing secret";
      toast.message = String(error);
    }
  }

  return <Action.SubmitForm icon={Icon.Upload} title="Share Secret" onSubmit={handleSubmit} />;
}
```

----------------------------------------

TITLE: Paginate Raycast List with usePromise (TypeScript)
DESCRIPTION: This snippet demonstrates how to implement pagination for a Raycast `List` component using the `usePromise` hook from `@raycast/utils`. It fetches data asynchronously in pages as the user scrolls, managing loading state and `hasMore` status automatically via the hook's `pagination` object. It requires `@raycast/api` and `@raycast/utils` version 1.69.0 or higher.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/api-reference/user-interface/list.md#_snippet_2

LANGUAGE: TypeScript
CODE:
```
import { setTimeout } from "node:timers/promises";
import { useState } from "react";
import { List } from "@raycast/api";
import { usePromise } from "@raycast/utils";

export default function Command() {
  const [searchText, setSearchText] = useState("");

  const { isLoading, data, pagination } = usePromise(
    (searchText: string) => async (options: { page: number }) => {
      await setTimeout(200);
      const newData = Array.from({ length: 25 }, (_v, index) => ({
        index,
        page: options.page,
        text: searchText,
      }));
      return { data: newData, hasMore: options.page < 10 };
    },
    [searchText]
  );

  return (
    <List isLoading={isLoading} onSearchTextChange={setSearchText} pagination={pagination}>
      {data?.map((item) => (
        <List.Item
          key={`${item.page} ${item.index} ${item.text}`}
          title={`Page ${item.page} Item ${item.index}`}
          subtitle={item.text}
        />
      ))}
    </List>
  );
}
```

----------------------------------------

TITLE: Migrating Clipboard Methods Raycast API JS
DESCRIPTION: Demonstrates how to use the new `Clipboard` namespace in Raycast API v1.28.0 to perform copy, clear, and paste operations, replacing deprecated top-level functions. Requires importing `Clipboard` from `@raycast/api`.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/migration/v1.28.0.md#_snippet_0

LANGUAGE: js
CODE:
```
import { Clipboard } from "@raycast/api";

// deprecated copyTextToClipboard
await Clipboard.copy("text");

// deprecated clearClipboard
await Clipboard.clear();

// deprecated pasteText
await Clipboard.paste("text");
```

----------------------------------------

TITLE: Implementing Manual Form Validation (TypeScript)
DESCRIPTION: This snippet shows a manual approach to form validation in a Raycast extension using React's `useState` hook. It demonstrates how to manage error states for individual form fields (`nameError`, `passwordError`) and implement validation logic within `onBlur` and error clearing within `onChange` callbacks. Requires React and Raycast API.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/information/best-practices.md#_snippet_3

LANGUAGE: typescript
CODE:
```
import { Form } from "@raycast/api";
import { useState } from "react";

export default function Command() {
  const [nameError, setNameError] = useState<string | undefined>();
  const [passwordError, setPasswordError] = useState<string | undefined>();

  function dropNameErrorIfNeeded() {
    if (nameError && nameError.length > 0) {
      setNameError(undefined);
    }
  }

  function dropPasswordErrorIfNeeded() {
    if (passwordError && passwordError.length > 0) {
      setPasswordError(undefined);
    }
  }

  return (
    <Form>
      <Form.TextField
        id="nameField"
        title="Full Name"
        placeholder="Tim Cook"
        error={nameError}
        onChange={dropNameErrorIfNeeded}
        onBlur={(event) => {
          if (event.target.value?.length == 0) {
            setNameError("The field should't be empty!");
          } else {
            dropNameErrorIfNeeded();
          }
        }}
      />
      <Form.PasswordField
        id="password"
        title="New Password"
        error={passwordError}
        onChange={dropPasswordErrorIfNeeded}
        onBlur={(event) => {
          const value = event.target.value;
          if (value && value.length > 0) {
            if (!validatePassword(value)) {
              setPasswordError("Password should be at least 8 characters!");
            } else {
              dropPasswordErrorIfNeeded();
            }
          } else {
            setPasswordError("The field should't be empty!");
          }
        }}
      />
      <Form.TextArea id="bioTextArea" title="Add Bio" placeholder="Describe who you are" />
      <Form.DatePicker id="birthDate" title="Date of Birth" />
    </Form>
  );
}

function validatePassword(value: string): boolean {
  return value.length >= 8;
}
```

----------------------------------------

TITLE: Extending Mantine Theme Colors Type (TypeScript)
DESCRIPTION: Provides TypeScript module declarations to extend the MantineThemeColorsOverride interface, allowing custom color names to be recognized by the type system for improved developer experience and type safety.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/theming/extend-theme.mdx#_snippet_6

LANGUAGE: ts
CODE:
```
import { Tuple } from "@mantine/core";

type CustomColors = "primaryColorName" | "secondaryColorName";

declare module "@mantine/core" {
  export interface MantineThemeColorsOverride {
    colors: Record<CustomColors, Tuple<string, 10>>;;
  }
}
// or if you want to "extend" standard colors
import { Tuple, DefaultMantineColor } from "@mantine/core";

type ExtendedCustomColors = "primaryColorName" | "secondaryColorName" | DefaultMantineColor;

declare module "@mantine/core" {
  export interface MantineThemeColorsOverride {
    colors: Record<ExtendedCustomColors, Tuple<string, 10>>;;
  }
}
```

----------------------------------------

TITLE: Rendering Grid Items from State JSX
DESCRIPTION: This snippet shows how to dynamically render `Grid.Item` components within a Raycast `Grid` by mapping over an array of data stored in component state. It demonstrates setting the `key`, `content`, `title`, and `subtitle` props for each item based on the data structure. This pattern is common for displaying lists of items fetched asynchronously or managed locally.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/api-reference/user-interface/grid.md#_snippet_4

LANGUAGE: jsx
CODE:
```
{state.data.map((item) => (
 <Grid.Item
 key={`${item.index} ${item.page} ${item.text}`}
 content=""
 title={`Page: ${item.page} Item ${item.index}`}
 subtitle={item.text}
 />
 ))}
 </Grid>
 );
}
```

----------------------------------------

TITLE: Full Pagination Example with Raycast List (useFetch Hook, TSX)
DESCRIPTION: This complete example demonstrates integrating the `useFetch` hook with offset-based pagination into a Raycast command using the `List` component. It shows how to pass the `pagination` object to the `List` and render the fetched data.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/utils-reference/react-hooks/useFetch.md#_snippet_7

LANGUAGE: tsx
CODE:
```
import { Icon, Image, List } from "@raycast/api";
import { useFetch } from "@raycast/utils";
import { useState } from "react";

type SearchResult = { companies: Company[]; page: number; totalPages: number };
type Company = { id: number; name: string; smallLogoUrl?: string };
export default function Command() {
  const [searchText, setSearchText] = useState("");
  const { isLoading, data, pagination } = useFetch(
    (options) =>
      "https://api.ycombinator.com/v0.1/companies?" +
      new URLSearchParams({ page: String(options.page + 1), q: searchText }).toString(),
    {
      mapResult(result: SearchResult) {
        return {
          data: result.companies,
          hasMore: result.page < result.totalPages,
        };
      },
      keepPreviousData: true,
      initialData: [],
    },
  );

  return (
    <List isLoading={isLoading} pagination={pagination} onSearchTextChange={setSearchText}>
      {data.map((company) => (
        <List.Item
          key={company.id}
          icon={{ source: company.smallLogoUrl ?? Icon.MinusCircle, mask: Image.Mask.RoundedRectangle }}
          title={company.name}
        />
      ))}
    </List>
  );
}
```

----------------------------------------

TITLE: Handling Errors with Toast in Raycast (TypeScript)
DESCRIPTION: Demonstrates how to catch and display errors using Raycast's `showToast` function with `Toast.Style.Failure`. It uses React hooks (`useState`, `useEffect`) to simulate an error occurring after a delay and then shows a toast notification to the user.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/information/best-practices.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { Detail, showToast, Toast } from "@raycast/api";
import { useEffect, useState } from "react";

export default function Command() {
  const [error, setError] = useState<Error>();

  useEffect(() => {
    setTimeout(() => {
      setError(new Error("Booom ðŸ’¥"));
    }, 1000);
  }, []);

  useEffect(() => {
    if (error) {
      showToast({
        style: Toast.Style.Failure,
        title: "Something went wrong",
        message: error.message,
      });
    }
  }, [error]);

  return <Detail markdown="Example for proper error handling" />;
}
```

----------------------------------------

TITLE: Declaring Complex Mapping in Storage (Rust/Cairo)
DESCRIPTION: Demonstrates how to declare a complex mapping within the `Storage` struct using `LegacyMap`. This example shows a mapping from a tuple of `ContractAddress` to a `u256` value, commonly used for allowances in ERC20.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/charged/assets/cairoBook/ch09-01-contract-syntaxes.md#_snippet_3

LANGUAGE: Rust/Cairo
CODE:
```
struct Storage{
    allowances: LegacyMap::<(ContractAddress, ContractAddress), u256>
}
```

----------------------------------------

TITLE: Using Action, ActionPanel, and List in Raycast (TypeScript)
DESCRIPTION: Demonstrates how to structure a Raycast command using ActionPanel and List components, incorporating both built-in actions (OpenInBrowser, CopyToClipboard) and a custom Action with an onAction handler.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/api-reference/user-interface/actions.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { ActionPanel, Action, List } from "@raycast/api";

export default function Command() {
  return (
    <List navigationTitle="Open Pull Requests">
      <List.Item
        title="Docs: Update API Reference"
        subtitle="#1"
        actions={
          <ActionPanel title="#1 in raycast/extensions">
            <Action.OpenInBrowser url="https://github.com/raycast/extensions/pull/1" />
            <Action.CopyToClipboard title="Copy Pull Request Number" content="#1" />
            <Action title="Close Pull Request" onAction={() => console.log("Close PR #1")} />
          </ActionPanel>
        }
      />
    </List>
  );
}
```

----------------------------------------

TITLE: Using Mantine useInputState Hook with Inputs (TSX)
DESCRIPTION: Demonstrates how to use the `useInputState` hook with both native HTML inputs and Mantine components like `TextInput` and `NumberInput`. It also includes a comparison with the standard `useState` hook to highlight the simplified change handler.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/hooks/use-input-state.mdx#_snippet_0

LANGUAGE: tsx
CODE:
```
import { useState } from "react";
import { useInputState } from "@mantine/hooks";
import { TextInput, NumberInput } from "@mantine/core";

function WithUseInputState() {
  const [stringValue, setStringValue] = useInputState("");
  const [numberValue, setNumberValue] = useInputState(0);

  return (
    <>
      <input type="text" value={stringValue} onChange={setStringValue} />
      <TextInput value={stringValue} onChange={setStringValue} />
      <NumberInput value={numberValue} onChange={setNumberValue} />
    </>
  );
}

function WithUseState() {
  const [stringValue, setStringValue] = useState("");
  const [numberValue, setNumberValue] = useState(0);

  return (
    <>
      <input type="text" value={stringValue} onChange={(event) => setStringValue(event.currentTarget.value)} />
      <TextInput value={stringValue} onChange={(event) => setStringValue(event.currentTarget.value)} />
      <NumberInput value={numberValue} onChange={setNumberValue} />
    </>
  );
}

```

----------------------------------------

TITLE: Using useSetState Hook with Object State - TSX
DESCRIPTION: Demonstrates how to initialize and update object state using the useSetState hook. It shows examples of initializing with an object, performing partial updates by shallow merging, and using a functional updater to derive the next state based on the current state.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/hooks/use-set-state.mdx#_snippet_0

LANGUAGE: tsx
CODE:
```
const [state, setState] = useSetState({ name: "John", age: 35, job: "Engineer" });

state; // -> { name: 'John', age: 35, job: 'Engineer' }

setState({ name: "Jane" }); // -> { name: 'Jane', age: 35, job: 'Engineer' }
setState({ age: 25, job: "Manager" }); // -> { name: 'Jane', age: 25, job: 'Manager' }
setState((current) => ({ age: current.age + 7 })); // -> { name: 'Jane', age: 32, job: 'Manager' }
```

----------------------------------------

TITLE: Initializing Form with Rules Object Validation (TSX)
DESCRIPTION: Initializes a form using the `useForm` hook with `initialValues` and a `validate` object. The `validate` object contains functions for specific fields that return an error message (or null) based on the field's value. Shows how to call `form.validate()` to trigger validation and access the resulting errors via `form.errors`.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/form/use-form.mdx#_snippet_6

LANGUAGE: tsx
CODE:
```
const form = useForm({
  initialValues: { name: "", age: 0 },

  // functions will be used to validate values at corresponding key
  validate: {
    name: (value) => (value.length < 2 ? "Name must have at least 2 letters" : null),
    age: (value) => (value < 18 ? "You must be at least 18 to register" : null),
  },
});

form.errors; // -> {} (empty object, no errors)

form.validate();
form.errors; // -> { name: 'Name must have at least 2 letters', age: 'You must be at least 18 to register' }

form.setValues({ name: "John", age: 20 });
form.validate();
form.errors; // -> {} (empty object, no errors)
```

----------------------------------------

TITLE: Performing Optimistic Updates with useCachedPromise Mutate (TypeScript)
DESCRIPTION: This example demonstrates using the `mutate` function returned by useCachedPromise to perform an asynchronous update (like an API call) while immediately applying an `optimisticUpdate` to the local data. This provides a more responsive user experience by updating the UI instantly, with automatic rollback if the asynchronous operation fails.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/utils-reference/react-hooks/useCachedPromise.md#_snippet_3

LANGUAGE: TypeScript
CODE:
```
import { Detail, ActionPanel, Action, showToast, Toast } from "@raycast/api";
import { useCachedPromise } from "@raycast/utils";

export default function Command() {
  const { isLoading, data, mutate } = useCachedPromise(
    async (url: string) => {
      const response = await fetch(url);
      const result = await response.text();
      return result;
    },
    ["https://api.example"],
  );

  const appendFoo = async () => {
    const toast = await showToast({ style: Toast.Style.Animated, title: "Appending Foo" });
    try {
      await mutate(
        // we are calling an API to do something
        fetch("https://api.example/append-foo"),
        {
          // but we are going to do it on our local data right away,
          // without waiting for the call to return
          optimisticUpdate(data) {
            return data + "foo";
          },
        },
      );
      // yay, the API call worked!
      toast.style = Toast.Style.Success;
      toast.title = "Foo appended";
    } catch (err) {
      // oh, the API call didn't work :(
      // the data will automatically be rolled back to its previous value
      toast.style = Toast.Style.Failure;
      toast.title = "Could not append Foo";
      toast.message = err.message;
    }
  };

  return (
    <Detail
      isLoading={isLoading}
      markdown={data}
      actions={
        <ActionPanel>
          <Action title="Append Foo" onAction={() => appendFoo()} />
        </ActionPanel>
      }
    />
  );
}
```

----------------------------------------

TITLE: Example Usage of useForm Hook in Raycast (TSX)
DESCRIPTION: Provides a complete example of using the `useForm` hook within a Raycast command component. It defines an interface for form values, initializes the hook with `onSubmit` and `validation` rules (including `FormValidation.Required` and custom validation functions), and renders a Raycast `Form` component with various input fields linked to the hook's `itemProps` and `handleSubmit`.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/utils-reference/react-hooks/useForm.md#_snippet_1

LANGUAGE: tsx
CODE:
```
import { Action, ActionPanel, Form, showToast, Toast } from "@raycast/api";
import { useForm, FormValidation } from "@raycast/utils";

interface SignUpFormValues {
  firstName: string;
  lastName: string;
  birthday: Date | null;
  password: string;
  number: string;
  hobbies: string[];
}

export default function Command() {
  const { handleSubmit, itemProps } = useForm<SignUpFormValues>({
    onSubmit(values) {
      showToast({
        style: Toast.Style.Success,
        title: "Yay!",
        message: `${values.firstName} ${values.lastName} account created`,
      });
    },
    validation: {
      firstName: FormValidation.Required,
      lastName: FormValidation.Required,
      password: (value) => {
        if (value && value.length < 8) {
          return "Password must be at least 8 symbols";
        } else if (!value) {
          return "The item is required";
        }
      },
      number: (value) => {
        if (value && value !== "2") {
          return "Please select '2'";
        }
      },
    },
  });
  return (
    <Form
      actions={
        <ActionPanel>
          <Action.SubmitForm title="Submit" onSubmit={handleSubmit} />
        </ActionPanel>
      }
    >
      <Form.TextField title="First Name" placeholder="Enter first name" {...itemProps.firstName} />
      <Form.TextField title="Last Name" placeholder="Enter last name" {...itemProps.lastName} />
      <Form.DatePicker title="Date of Birth" {...itemProps.birthday} />
      <Form.PasswordField
        title="Password"
        placeholder="Enter password at least 8 characters long"
        {...itemProps.password}
      />
      <Form.Dropdown title="Your Favorite Number" {...itemProps.number}>
        {[1, 2, 3, 4, 5, 6, 7].map((num) => {
          return <Form.Dropdown.Item value={String(num)} title={String(num)} key={num} />;
        })}
      </Form.Dropdown>
    </Form>
  );
}
```

----------------------------------------

TITLE: Adjusting Default Imports for Node.js Modules (JavaScript)
DESCRIPTION: This snippet illustrates a required change in import statements due to an update in the build tool's handling of `default` exports. For npm packages that lack a `default` export when running in a Node.js environment, a default import must be changed to a namespace import to ensure compatibility and proper module loading.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/changelog.md#_snippet_8

LANGUAGE: JavaScript
CODE:
```
import caniuse from "caniuse-api"
```

LANGUAGE: JavaScript
CODE:
```
import * as caniuse from "caniuse-api"
```

----------------------------------------

TITLE: Handling Form Submission with Mantine useForm onSubmit in TSX
DESCRIPTION: Illustrates the usage of the `form.onSubmit` handler, which wraps a custom submission function. This handler automatically prevents the default form submission event, triggers form validation, and calls the provided function with the form values only if all fields are valid. It also shows how to derive the type of form values using `typeof form.values`.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/mantine/assets/docs/form/use-form.mdx#_snippet_13

LANGUAGE: tsx
CODE:
```
import { useForm } from "@mantine/form";

function Demo() {
  const form = useForm({ initialValues: { name: "", age: 0 } });

  // You can get form values type using typeof to store function separately
  const handleSubmit = (values: typeof form.values) => console.log(values);

  return <form onSubmit={form.onSubmit(handleSubmit)}>{/* ...inputs */}</form>;
}
```

----------------------------------------

TITLE: Execute JavaScript with Placeholders and System Commands
DESCRIPTION: This snippet demonstrates how to use the `{{js:...}}` placeholder to execute JavaScript code that integrates with other Raycast placeholders (`{{date}}`, `{{url}}`), interacts with the Music app using JXA and AppleScript via shell, searches Google, and creates a note in the Notes app. It showcases combining various Raycast features within a single JavaScript execution block.
SOURCE: https://github.com/raycast/extensions/blob/main/extensions/promptlab/assets/placeholders_guide.md#_snippet_14

LANGUAGE: JavaScript
CODE:
```
Summarize this:

###
{{js:
const dateStr = '{{date format="MMMM d, yyyy"}}'

// Run JXA to get the name of the most played song in Music.
jxa(`(() => {
        const music = Application("Music");
        const frequentPlaylist = music.playlists["Top 25 Most Played"];
        const tracks = frequentPlaylist.tracks();
        const mostPlayedTrack = tracks[1];
        return mostPlayedTrack.name();
    })()`)

    // Play the song and get the artist.
 .then((favSong) => 
        as(`tell application "Music"
                play track "${favSong.trim()}"
                delay 1
                set theArtist to artist of current track
                stop
                return theArtist
            end tell`)
    // Search Google for songs by the artist.
 .then((theArtist) => url(`https://google.com/search?q=Journey%20dont%20stop%believin%22`)

    // Create a new note in Notes with the search results as the body, show note, then reactivate Raycast.
 .then((text) => {
        const visibleText = text.replaceAll("'", "'\\''").replaceAll('"', '\\"').replaceAll("\n", "<br /><br />")
     shell(`osascript -e 'use scripting additions' -e 'tell application "Notes"' -e 'set newNote to make new note with properties {body: "${dateStr}<br /><br />${visibleText}"}' -e 'show newNote' -e 'end tell' -e 'delay 0.5' -e 'tell application "System Events" to open location "raycast://"'`);
     return visibleText;
    })));
}}
###
```

----------------------------------------

TITLE: Creating a View Command (TypeScript)
DESCRIPTION: Demonstrates the basic structure of a Raycast view command using TypeScript. It exports a default function that returns a React component (Detail) to render a simple markdown view.
SOURCE: https://github.com/raycast/extensions/blob/main/docs/information/lifecycle/README.md#_snippet_0

LANGUAGE: typescript
CODE:
```
import { Detail } from "@raycast/api";

// Returns the main React component for a view command
export default function Command() {
  return <Detail markdown="# Hello" />;
}
```